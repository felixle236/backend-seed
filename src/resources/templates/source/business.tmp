import I{pascalName}Business from './interfaces/I{pascalName}Business'; // eslint-disable-line
import {pascalName}Repository from '../repository/{pascalName}Repository';
import {pascalName} from '../model/{camelName}/{pascalName}';
import {pascalName}Create from '../model/{camelName}/{pascalName}Create';
import {pascalName}Update from '../model/{camelName}/{pascalName}Update';
import {ErrorCommon} from '../model/common/Error';

class {pascalName}Business implements I{pascalName}Business {
    private static _instance: I{pascalName}Business;
    private {camelName}Repository: {pascalName}Repository;

    private constructor() {
        this.{camelName}Repository = new {pascalName}Repository();
    }

    static get instance() {
        if (!{pascalName}Business._instance)
            {pascalName}Business._instance = new {pascalName}Business();
        return {pascalName}Business._instance;
    }

    async getList(name?: string, page?: number, limit?: number): Promise<{pascalName}[]> {
        let param = {
            query: <any>{}
        };
        if (name)
            param.query.name = new RegExp(name, 'i');

        let {camelName}s = await this.{camelName}Repository.find(param, {name: 1}, page, limit);
        return {pascalName}.parseArray({camelName}s);
    }

    async count(name?: string): Promise<number> {
        let param = {
            query: <any>{}
        };
        if (name)
            param.query.name = new RegExp(name, 'i');

        return await this.{camelName}Repository.count(param);
    }

    async get(_id: string): Promise<{pascalName} | undefined> {
        if (!_id)
            return;

        let {camelName} = await this.{camelName}Repository.get(_id);
        return {camelName} && new {pascalName}({camelName});
    }

    async get{pascalName}ByName(name: string): Promise<{pascalName} | undefined> {
        if (!name)
            return;

        let {camelName} = await this.{camelName}Repository.findOne({query: {name: name.trim()}});
        return {camelName} && new {pascalName}({camelName});
    }

    async create(data: any): Promise<{pascalName} | undefined> {
        let {camelName};
        let dataCreate = new {pascalName}Create(data);

        if (validateName(dataCreate.name)) {
            {camelName} = await this.get{pascalName}ByName(dataCreate.name);
            if ({camelName})
                throw new ErrorCommon(104, 'Name');

            {camelName} = await this.{camelName}Repository.create(dataCreate);
        }

        return {camelName} && new {pascalName}({camelName});
    }

    async update(_id: string, data: any): Promise<boolean> {
        let {camelName};
        let dataUpdate = new {pascalName}Update(data);

        if (validateName(dataUpdate.name)) {
            {camelName} = await this.get{pascalName}ByName(dataUpdate.name);
            if ({camelName} && {camelName}._id === _id)
                throw new ErrorCommon(104, 'Name');

            {camelName} = await this.{camelName}Repository.findOneAndUpdate({_id}, dataUpdate);
        }
        return true;
    }

    async delete(_id: string): Promise<boolean> {
        return await this.{camelName}Repository.delete(_id);
    }

    async initial{pascalName}s(data: {isRequired: boolean, data: any}[], isRequired = false): Promise<boolean> {
        if (!data || !Array.isArray(data))
            throw new ErrorCommon(101, 'Data');

        for (let i = 0; i < data.length; i++) {
            let item = data[i];
            if (item.isRequired || isRequired) {
                await this.create(item.data).then({camelName} => {
                    if ({camelName})
                        console.log(`{pascalName} '${item.data.name}' has created.`);
                }).catch(error => {
                    if (error.code && !error.code.toString().startsWith('COM'))
                        console.log(`{pascalName} '${item.data.name}' cannot create with error`, error);
                });
            }
        }
        console.log('\x1b[32m', 'Initialize {camelName}s have done.', '\x1b[0m');
        return true;
    }
}

function validateName(name: string): boolean {
    if (!name)
        throw new ErrorCommon(105, 'Name');
    else if (name.trim().length < 4)
        throw new ErrorCommon(201, 'name', 4);

    return true;
}

export default {pascalName}Business;
